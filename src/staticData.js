// Generated by CoffeeScript 1.10.0
(function() {
  var METHODS, config, fileIO, fs, get, path, save;

  fs = require('fs-extra');

  config = require('./config');

  fileIO = require('./fileIO');

  path = require('path');


  /*
    TODO: Ideal similarity search when recorded data is not found:
    Individual resource
    1. Return exact item
    2. Return sibling with nearby id
    3. Return first item of a list with the same resource name (eg: request for animal/7 can return JSON.parse(animals.json)[0])
    4. 404
    Individual resource w/ query params
    1. Return exact item with exact query params
    2. Find same resource with a similar query (scoring similar queries should be fun)
    3. Find same resource with no query
    4. Find sibling resource with exact query params
    5. Find sibling resource with similar query
    6. Find sibling resource with no query
    7. 404
    Collection
    1. return exact collection
    2. Search for a child item(s). If there are any, add them all to an array and return that. (eg: [1.json, 2.json])
    3. 404
    Collection w/ query params
    1. return exact collection w/ matching params
    2. return exact collection with similar query
    3. exact colleciton no query
    4. child items merged into an array
    5. 404
   */

  get = function(req, res, next) {
    var file, fileCallback;
    file = fileIO.convertReqToFilename(req);
    fileCallback = function(err, data) {
      var sibling;
      if ((err != null ? err.code : void 0) === 'ENOENT' && config.sameSameSiblings) {
        console.log("  Didn't find `" + file + "`. Looking for similar siblings...");
        sibling = fileIO.getSiblingName(file);
        if (sibling) {
          console.log("  Found a sibling. Returning `" + (path.basename(sibling)) + "`");
          return fs.readJson(sibling, fileCallback);
        } else {
          return next();
        }
      } else if ((err != null ? err.code : void 0) === 'ENOENT') {
        console.log("  File not found: " + file);
        return next();
      } else if (err) {
        console.log("  Unhandled error", {
          err: err,
          data: data
        });
        return next();
      } else {
        res.setHeader('Access-Control-Allow-Methods', 'GET');
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.send(data);
        return next();
      }
    };
    return fs.readJson(file, fileCallback);
  };

  save = function(req, data) {
    var filename;
    filename = fileIO.convertReqToFilename(req);
    return fs.outputJson(filename, data, function(err) {
      if (err) {
        return console.log("Couldn't write file `" + filename + "`", err);
      } else {
        return console.log("Wrote file: `" + filename + "`");
      }
    });
  };

  METHODS = {
    GET: get,
    POST: function(req, res, next) {
      next();
      return console.warn("staticData.POST not yet supported", arguments);
    },
    PUT: function(req, res, next) {
      next();
      return console.warn("staticData.PUT not yet supported", arguments);
    },
    DELETE: function(req, res, next) {
      next();
      return console.warn("staticData.DELETE not yet supported", arguments);
    }
  };

  module.exports = {
    save: save,
    fetchDataForRequest: function(req) {
      console.log(req.method + " localhost:" + config.port + " " + req.path);
      return METHODS[req.method].apply(this, arguments);
    }
  };

}).call(this);
